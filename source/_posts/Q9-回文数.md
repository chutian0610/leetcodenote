---
title: Q9.回文数
date: 2020-05-09 16:59:51
mathjax: true
top: 9
tags:
  - 回文
---
# Q9.回文数

判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

```
示例 1:

输入: 121
输出: true
```

```
示例 2:

输入: -121
输出: false
解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

```
示例 3:

输入: 10
输出: false
解释: 从右向左读, 为 01 。因此它不是一个回文数。
```

## 思路

### 转化为数组或字符串

* 遍历数字位数，转化为数组或字符串。
* 两个指针分别指向从字符串首尾，向中间移动，步长为1。
* 如果指向的值不同那么返回false，如果相同继续move，直至交汇(位数是奇数偶数的条件不同)。返回true

时间复杂度(n为数字位数):

1. 转化为数组或字符串:$log_{10}(n)$
2. 指针遍历: $O(n)$.

空间复杂度: $O(n)$

### 挑战空间复杂度: $O(1)$

上面思路是将整个数字的位数计算出来，空间复杂度: $O(n)$。优化的点就是能不能把首尾指针的比较操作和遍历位数结合在一起。

我们可以**通过取整和取余操作获取整数中对应的数字进行比较**。

举个例子：8998 这个数字。

* 通过计算 8998 / 1000， 得首位8
* 通过计算 8998 % 10， 可得末位8
* 进行比较
* 再将 99 取出来继续比较

伪码:

1. 获取数字位数N
2. 通过位数，整除$10^N$得首位
3. 对10取余得末位
4. 首末位不同，返回false
5. 对$10^N$取余,在除以10，等到新的x，N=N-2;重复第2步。
6. x为0时终止,返回true。

注意,当去掉首位时，首位后面的连续个0也会被去掉。

|step|0|1|2|
|:---|:---|:---|:---|
|x|100201|20|2|
|N|5|3|1|
|10^N|100000|1000|10|
|首|1|0|0|
|尾|1|0|2（2!=0）|

> result :false

|step|0|1|2|3|
|:---|:---|:---|:---|:---|
|x|10201|20|2|3（break）|
|N|4|2|0|
|10^N|10000|100|1|
|首|1|0|2|
|尾|1|0|2|

> result :true

## 代码

```java
public class Palindrome {
    public boolean isPalindrome(int x) {
        //边界判断
        if (x < 0) {
            return false;
        }
        int div = 1;

        while (x / div >= 10) {div *= 10;}

        while (x > 0) {
            int left = x / div;
            int right = x % 10;
            if (left != right) { return false;}
            x = (x % div) / 10;
            div /= 100;
        }
        return true;
    }
}
```